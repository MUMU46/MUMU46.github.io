<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="google-site-verification" content="" />
  <meta name="referrer" content="unsafe-url">
  
  <title>set c++</title>
  <meta name="author" content="MUMU">
  <meta name="description" content="Set c++C++STL标准库中的容器
set 是关联容器，含有键值类型对象的已排序集，搜索、移除和插入拥有对数复杂度。set 内部通常采用红黑树实现。平衡二叉树的特性使得 set 非常适合处理需要同时兼顾查找、插入与删除的情况。

和数学中的集合相似，set 中不会出现值相同的元素。
set 容">
  
  
  <meta property="og:title" content="set c++"/>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:site_name" content="MUMU&#39;s blog"/>
  <link href="/apple-touch-icon-precomposed.png" sizes="180x180" rel="apple-touch-icon-precomposed">
  <link rel="alternate" href="/atom.xml" title="MUMU&#39;s blog" type="application/atom+xml">
  <link rel="stylesheet" href="/css/m.min.css">
  <link rel="icon" type="image/x-icon" href="/favicon.ico">
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script>

<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <a id="top"></a>
  <div id="main">
    <div class="main-ctnr">
      <div class="behind">
  <a href="/" class="back black-color">
    <svg class="i-close" viewBox="0 0 32 32" width="22" height="22" fill="none" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="3">
        <path d="M2 30 L30 2 M30 30 L2 2"></path>
    </svg>
  </a>
  
</div>


  <article class="standard post">
    <div class="title">
      
  
    <h1 class="page-title center">
        set c++
    </h1>
  


    </div>
    <div class="meta center">
      <time datetime="2023-10-13T12:54:37.000Z" itemprop="datePublished">
  <svg class="i-calendar" viewBox="0 0 32 32" width="16" height="16" fill="none" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2">
    <path d="M2 6 L2 30 30 30 30 6 Z M2 15 L30 15 M7 3 L7 9 M13 3 L13 9 M19 3 L19 9 M25 3 L25 9"></path>
  </svg>
  &nbsp;
  2023-10-13
</time>





    
    &nbsp;
    <svg class="i-tag" viewBox="0 0 32 32" width="16" height="16" fill="none" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2">
      <circle cx="24" cy="8" r="2"></circle>
      <path d="M2 18 L18 2 30 2 30 14 14 30 Z"></path>
    </svg>
    &nbsp;
    <a href="/tags/c/">c++</a>·<a href="/tags/set/">set</a>


    </div>
    <hr>
    
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Set-c"><span class="toc-text">Set c++</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#C-STL%E6%A0%87%E5%87%86%E5%BA%93%E4%B8%AD%E7%9A%84%E5%AE%B9%E5%99%A8"><span class="toc-text">C++STL标准库中的容器</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#set-%E5%AE%B9%E5%99%A8%E5%AE%9A%E4%B9%89%E4%BA%8E-lt-set-gt-%E5%A4%B4%E6%96%87%E4%BB%B6%EF%BC%8C%E5%B9%B6%E4%BD%8D%E4%BA%8E-std-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E4%B8%AD"><span class="toc-text">set 容器定义于&lt;set&gt;头文件，并位于 std 命名空间中</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA"><span class="toc-text">创建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95"><span class="toc-text">成员方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E4%B8%8E%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C"><span class="toc-text">插入与删除操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%8D%E5%8E%86"><span class="toc-text">遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE"><span class="toc-text">查找</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#set-%E5%9C%A8%E8%B4%AA%E5%BF%83%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">set 在贪心中的使用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96"><span class="toc-text">其他</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#unorderdmap"><span class="toc-text">unorderdmap</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#unordered-map-%E5%AE%B9%E5%99%A8%E5%92%8C-map-%E5%AE%B9%E5%99%A8%E4%BB%85%E6%9C%89%E4%B8%80%E7%82%B9%E4%B8%8D%E5%90%8C%EF%BC%8C%E5%8D%B3-map-%E5%AE%B9%E5%99%A8%E4%B8%AD%E5%AD%98%E5%82%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E6%98%AF%E6%9C%89%E5%BA%8F%E7%9A%84%EF%BC%8C%E8%80%8C-unordered-map-%E5%AE%B9%E5%99%A8%E4%B8%AD%E6%98%AF%E6%97%A0%E5%BA%8F%E7%9A%84%E3%80%82"><span class="toc-text">unordered_map 容器和 map 容器仅有一点不同，即 map 容器中存储的数据是有序的，而 unordered_map 容器中是无序的。</span></a></li></ol></li></ol></li></ol></li></ol>
    
    <div class="picture-container">
      
    </div>
    <h2 id="Set-c"><a href="#Set-c" class="headerlink" title="Set c++"></a>Set c++</h2><h3 id="C-STL标准库中的容器"><a href="#C-STL标准库中的容器" class="headerlink" title="C++STL标准库中的容器"></a>C++STL标准库中的容器</h3><blockquote>
<p><code>set</code> 是关联容器，含有键值类型对象的已排序集，搜索、移除和插入拥有对数复杂度。<code>set</code> 内部通常采用<strong>红黑树</strong>实现。平衡二叉树的特性使得 <code>set</code> 非常适合处理需要同时兼顾查找、插入与删除的情况。</p>
</blockquote>
<p>和数学中的集合相似，<code>set</code> 中不会出现值相同的元素。</p>
<h5 id="set-容器定义于-lt-set-gt-头文件，并位于-std-命名空间中"><a href="#set-容器定义于-lt-set-gt-头文件，并位于-std-命名空间中" class="headerlink" title="set 容器定义于&lt;set&gt;头文件，并位于 std 命名空间中"></a>set 容器定义于<code>&lt;set&gt;</code>头文件，并位于 std 命名空间中</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> namesace std;</span><br></pre></td></tr></table></figure>

<h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><ul>
<li>默认构造函数</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set&lt;type&gt; myset</span><br></pre></td></tr></table></figure>

<ul>
<li>拷贝构造函数</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">set&lt;type&gt; <span class="title">copyset</span><span class="params">(myset)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h3><table>
<thead>
<tr>
<th>成员方法</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>begin()</td>
<td>返回指向容器中第一个（注意，是已排好序的第一个）元素的双向迭代器。如果 set 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td>
</tr>
<tr>
<td>end()</td>
<td>返回指向容器最后一个元素（注意，是已排好序的最后一个）所在位置后一个位置的双向迭代器，通常和 begin() 结合使用。如果 set 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td>
</tr>
<tr>
<td>rbegin()</td>
<td>返回指向最后一个（注意，是已排好序的最后一个）元素的反向双向迭代器。如果 set 容器用 const 限定，则该方法返回的是 const 类型的反向双向迭代器。</td>
</tr>
<tr>
<td>rend()</td>
<td>返回指向第一个（注意，是已排好序的第一个）元素所在位置前一个位置的反向双向迭代器。如果 set 容器用 const 限定，则该方法返回的是 const 类型的反向双向迭代器。</td>
</tr>
<tr>
<td>cbegin()</td>
<td>和 begin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的元素值。</td>
</tr>
<tr>
<td>cend()</td>
<td>和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的元素值。</td>
</tr>
<tr>
<td>crbegin()</td>
<td>和 rbegin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的元素值。</td>
</tr>
<tr>
<td>crend()</td>
<td>和 rend() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改容器内存储的元素值。</td>
</tr>
<tr>
<td>find(val)</td>
<td>在 set 容器中查找值为 val 的元素，如果成功找到，则返回指向该元素的双向迭代器；反之，则返回和 end() 方法一样的迭代器。另外，如果 set 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td>
</tr>
<tr>
<td>lower_bound(val)</td>
<td>返回一个指向当前 set 容器中第一个大于或等于 val 的元素的双向迭代器。如果 set 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td>
</tr>
<tr>
<td>upper_bound(val)</td>
<td>返回一个指向当前 set 容器中第一个大于 val 的元素的迭代器。如果 set 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td>
</tr>
<tr>
<td>equal_range(val)</td>
<td>该方法返回一个 pair 对象（包含 2 个双向迭代器），其中 pair.first 和 lower_bound() 方法的返回值等价，pair.second 和 upper_bound() 方法的返回值等价。也就是说，该方法将返回一个范围，该范围中包含的值为 val 的元素（set 容器中各个元素是唯一的，因此该范围最多包含一个元素）。</td>
</tr>
<tr>
<td>empty()</td>
<td>若容器为空，则返回 true；否则 false。</td>
</tr>
<tr>
<td>size()</td>
<td>返回当前 set 容器中存有元素的个数。</td>
</tr>
<tr>
<td>max_size()</td>
<td>返回 set 容器所能容纳元素的最大个数，不同的操作系统，其返回值亦不相同。</td>
</tr>
<tr>
<td>insert()</td>
<td>向 set 容器中插入元素。</td>
</tr>
<tr>
<td>erase()</td>
<td>删除 set 容器中存储的元素。</td>
</tr>
<tr>
<td>swap()</td>
<td>交换 2 个 set 容器中存储的所有元素。这意味着，操作的 2 个 set 容器的类型必须相同。</td>
</tr>
<tr>
<td>clear()</td>
<td>清空 set 容器中所有的元素，即令 set 容器的 size() 为 0。</td>
</tr>
<tr>
<td>emplace()</td>
<td>在当前 set 容器中的指定位置直接构造新元素。其效果和 insert() 一样，但效率更高。</td>
</tr>
<tr>
<td>emplace_hint()</td>
<td>在本质上和 emplace() 在 set 容器中构造新元素的方式是一样的，不同之处在于，使用者必须为该方法提供一个指示新元素生成位置的迭代器，并作为该方法的第一个参数。</td>
</tr>
<tr>
<td>count(val)</td>
<td>在当前 set 容器中，查找值为 val 的元素的个数，并返回。注意，由于 set 容器中各元素的值是唯一的，因此该函数的返回值最大为 1。</td>
</tr>
</tbody></table>
<h3 id="插入与删除操作"><a href="#插入与删除操作" class="headerlink" title="插入与删除操作"></a>插入与删除操作</h3><ul>
<li><code>insert(x)</code> 当容器中没有等价元素的时候，将元素 x 插入到 <code>set</code> 中。</li>
<li><code>erase(x)</code> 删除值为 x 的 <strong>所有</strong> 元素，返回删除元素的个数。</li>
<li><code>erase(pos)</code> 删除迭代器为 pos 的元素，要求迭代器必须合法。</li>
<li><code>erase(first,last)</code> 删除迭代器在 ![<a href="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7">first,last)</a> 范围内的所有元素。</li>
<li><code>clear()</code> 清空 <code>set</code>。</li>
</ul>
<h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><blockquote>
<p>迭代器: 分为输入迭代器(input iterator)、输出迭代器(output iterator)、<strong>前向迭代器</strong>(forward iterator)、<strong>双向迭代器</strong>(Bidirectional Iterator)、<strong>随机访问迭代器</strong>(Random Access Iterator) 5 种.</p>
<p>正向迭代器: 可进行p++、++p、*p操作</p>
<p>双向迭代器: 具有正向迭代器的全部功能, 还能进行p–、–p操作.</p>
<p>随机迭代器: p+i、p-i、p[i]、p-=i、p+=i</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//利用双向迭代器，遍历myset</span><br><span class="line">    for (auto iter = myset.begin(); iter != myset.end(); ++iter) &#123;</span><br><span class="line">        cout &lt;&lt; *iter &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><ul>
<li>count(x)<code>返回</code>set` 内键为 x 的元素数量。</li>
<li><code>find(x)</code> 在 <code>set</code> 内存在键为 x 的元素时会返回该元素的迭代器，否则返回 <code>end()</code>。</li>
<li><code>lower_bound(x)</code> 返回指向首个不小于给定键的元素的迭代器。如果不存在这样的元素，**返回 <code>end()</code>**。</li>
<li><code>upper_bound(x)</code> 返回指向首个大于给定键的元素的迭代器。如果不存在这样的元素，<strong>返回 <code>end()</code>。</strong></li>
<li><code>empty()</code> 返回容器是否为空。</li>
<li><code>size()</code> 返回容器内元素个数。</li>
</ul>
<h4 id="set-在贪心中的使用"><a href="#set-在贪心中的使用" class="headerlink" title="set 在贪心中的使用"></a><code>set</code> 在贪心中的使用</h4><p>在贪心算法中经常会需要出现类似 <strong>找出并删除最小的大于等于某个值的元素</strong>。这种操作能轻松地通过 <code>set</code> 来完成。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 现存可用的元素</span></span><br><span class="line">set&lt;<span class="keyword">int</span>&gt; available;</span><br><span class="line"><span class="comment">// 需要大于等于的值</span></span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找最小的大于等于x的元素</span></span><br><span class="line">set&lt;<span class="keyword">int</span>&gt;::iterator it = available.<span class="built_in">lower_bound</span>(x);</span><br><span class="line"><span class="keyword">if</span> (it == available.<span class="built_in">end</span>()) &#123;</span><br><span class="line">  <span class="comment">// 不存在这样的元素，则进行相应操作……</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 找到了这样的元素，将其从现存可用元素中移除</span></span><br><span class="line">  available.<span class="built_in">erase</span>(it);</span><br><span class="line">  <span class="comment">// 进行相应操作……</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p><code>map</code>也是一种关联容器, 存储的是一对一的键值对, 只能有一个相同键的元素, 其成员方法和set差不多:</p>
<p>特殊点:</p>
<ul>
<li>可以直接通过下标访问来进行查询或插入操作。例如 <code>mp[&quot;Alan&quot;]=100</code>。</li>
</ul>
<h3 id="unorderdmap"><a href="#unorderdmap" class="headerlink" title="unorderdmap"></a><code>unorderdmap</code></h3><h5 id="unordered-map-容器和-map-容器仅有一点不同，即-map-容器中存储的数据是有序的，而-unordered-map-容器中是无序的。"><a href="#unordered-map-容器和-map-容器仅有一点不同，即-map-容器中存储的数据是有序的，而-unordered-map-容器中是无序的。" class="headerlink" title="unordered_map 容器和 map 容器仅有一点不同，即 map 容器中存储的数据是有序的，而 unordered_map 容器中是无序的。"></a><code>unordered_map</code> 容器和 <code>map </code>容器仅有一点不同，即 map 容器中存储的数据是有序的，而 unordered_map 容器中是无序的。</h5>

  </article>
  <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  <div class="busuanzi center">
    页阅读量:&nbsp;<span id="busuanzi_value_page_pv"></span>&nbsp;・&nbsp;
    站访问量:&nbsp;<span id="busuanzi_value_site_pv"></span>&nbsp;・&nbsp;
    站访客数:&nbsp;<span id="busuanzi_value_site_uv"></span>
  </div>


    





    </div>
  </div>
  <footer class="page-footer"><div class="clearfix">
</div>
<div class="right-foot">
    <div class="firstrow">
        <a href="#top" target="_self">
        <svg class="i-caret-right" viewBox="0 0 32 32" width="24" height="24" fill="none" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="3">
            <path d="M10 30 L26 16 10 2 Z"></path>
        </svg>
        </a>
        © MUMU 2016-2021
    </div>
    <div class="secondrow">
        <a target="_blank" rel="noopener" href="https://github.com/gaoryrt/hexo-theme-pln">
        Theme Pln
        </a>
    </div>
</div>
<div class="clearfix">
</div>
</footer>
  <script src="//cdn.bootcss.com/jquery/2.2.1/jquery.min.js"></script>
<script src="/js/search.min.js"></script>
<script type="text/javascript">

// disqus scripts


// dropdown scripts
$(".dropdown").click(function(event) {
  var current = $(this);
  event.stopPropagation();
  $(current).children(".dropdown-content")[($(current).children(".dropdown-content").hasClass("open"))?'removeClass':'addClass']("open")
});
$(document).click(function(){
    $(".dropdown-content").removeClass("open");
})

var path = "/search.xml";
searchFunc(path, 'local-search-input', 'local-search-result');

</script>

</body>
</html>
